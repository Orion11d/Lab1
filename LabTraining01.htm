<html>
<head>
<title>ЛР 1. Базовий синтаксис мови C#</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style type="text/css">
<!--

.Head { 
  background-color: #6699CC; 
  font-family: "Tahoma", Arial, Helvetica, sans-serif 
}

h1 {
  font-family: "Tahoma", Arial, Helvetica, sans-serif; 
  font-size: x-large;
  font-style: normal
}

h2 {
  font-family: "Tahoma", Arial, Helvetica, sans-serif;
  font-size: large;
  font-weight: bold
}

h3 {
  font-family: "Tahoma", Arial, Helvetica, sans-serif;
  font-size: medium;
  font-weight: bold
}

h4 {
  font-family: "Tahoma", Arial, Helvetica, sans-serif;
  font-size: small;
  font-weight: bold}

ul { 
  margin: 0 0 0 40
}

.contents 
{  
  font-family: Arial, Helvetica, sans-serif; 
  font-style: normal;
  font-weight: normal;
  margin: 0px, 0px, 0px, 0px
}

pre {
  font-family: "Courier New", Courier, mono
}

.comments {
  font-family: "Courier New", Courier, mono; 
  color: #333399
}

.directves {
  color: #006633
}

.title {
  font-family: Arial, Helvetica, sans-serif;
  background-color: #6699CC
}

code {
  font-family: "Courier New", Courier, mono
}

.justified {
  text-align: justify;
  font-weight: normal
}

tt {
  font-family: "Tahoma", Arial, Helvetica, sans-serif;
  color: #0000CC
}

-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000">
<a href="Index.htm">Зміст</a>&nbsp;&nbsp;&nbsp;&nbsp;Попередня лабораторна робота&nbsp;&nbsp;&nbsp;&nbsp;<a href="LabTraining02.htm">Наступна 
лабораторна робота</a> 
<h3>Лабораторна робота 1</h3>
<table width="100%" border="0" height="26">
  <tr> 
    <td height="21" class="title"> 
      <h1 align="center" class="Head">Базовий синтаксис мови C#</h1>
    </td>
  </tr>
</table>
<h2>1 Завдання на лабораторну роботу</h2>
<h3>1.1 Індивідуальне завдання</h3>
<p class="justified">Створити консольну програму, в якій здійснюється обчислення 
  значень функції на певному інтервалі. У програмі треба визначити значення початку 
  інтервалу, кінця інтервалу, а також величини кроку, з яким змінюється аргумент. 
  Відповідні значення слід прочитати з клавіатури.</p>
<p class="justified">Безпосередньому створенню програми повинні передувати дослідження 
  поведінки функції на різних інтервалах, створення схеми алгоритму в нотації 
  діаграми діяльності.</p>
<p class="justified">Програма повинна містити визначення та введення необхідних 
  даних і один великий цикл, у тілі якого здійснюється </p>
<ul>
  <li>обчислення функції різними способами, залежно від значення аргументу </li>
  <li>виведення на консоль аргументу та результату на кожному кроці циклу.</li>
</ul>
<p class="justified">Програма повинна містити окрему статичну функцію для обчислення 
  значення <i>y</i> залежно від значення аргументу <i>x</i>. Варіант функціональної 
  залежності, який слід реалізувати у програмі, визначається відповідно до номеру 
  студента у списку групи.</p>
<p class="justified">Таблиця 1.1 - Індивідуальні завдання</p>
<p align="center"><img src="Images/01_Formula1.png" width="1104" height="713"><img src="Images/01_Formula2.png" width="1104" height="689"></p>
<p class="justified"></p>
<h3>1.2 Використання умовної операції</h3>
<p class="justified">Реалізувати алгоритм і програму, в якій уводиться <i>x</i>, 
  обчислюється та виводиться <i>y</i>, який дорівнює -1, якщо <i>x</i> &lt; 0, 
  дорівнює 0, якщо <i>x</i> = 0, та 1, якщо <i>x</i> &gt; 0. Використати тернарну 
  умовну операцію </p>
<h3>1.3 Робота з перемикачем</h3>
<p>Створити програму, в якій з клавіатури вводиться рядок <i>s </i>та обчислюються 
  значення <i>y</i> відповідно до таблиці:</p>
<div align="center"> 
  <table width="40%" border="1" cellspacing="0" cellpadding="3">
    <tr> 
      <td> 
        <div align="center"><i><b>s</b></i></div>
      </td>
      <td> 
        <div align="center"><i><b>y</b></i></div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">&quot;yes&quot;</div>
      </td>
      <td> 
        <div align="center">20</div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">&quot;no&quot;</div>
      </td>
      <td> 
        <div align="center">100</div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">інше значення</div>
      </td>
      <td> 
        <div align="center">0.5</div>
      </td>
    </tr>
  </table>
  <br>
</div>
<div align="center"></div>
<p></p>
<h3>1.4 Застосування null-сумісних типів</h3>
<p class="justified">Розробити програму, в якій визначена функція обчислення квадратного 
  кореня, яка повертає <b><code>null</code></b>, якщо корінь неможливо обчислити, 
  або знайдене значення квадратного кореня. Здійснити тестування у функції <code>Main()</code>.</p>
<h3>1.5 Сума ряду</h3>
<p class="justified">Увести з клавіатури ціле n та знайти суму ряду</p>
<p align="center"><i>y</i> = 1 + <sup>1</sup>/<sub>2</sub> + <sup>1</sup>/<sub>4</sub> 
  + <sup>1</sup>/<sub>8</sub> + <sup>1</sup>/<sub>16</sub> + ... <sup>1</sup>/<sub>2</sub>n</p>
<p class="justified">Змінюючи <i>n</i>, домогтися максимальної точності. Реалізувати 
  окрему функцію обчислення <i>y</i>. </p>
<h3>1.6 Факторіали</h3>
<p class="justified">Реалізувати програму, в якій уводиться n, викликається функція 
  обчислення факторіал числа n і виводиться на екран n! для n від 1 до 10:</p>
<p align="center">n! = 1 * 2 * ... * n.</p>
<h3></h3>
<p class="justified">Реалізувати два варіанти обчислення - за допомогою циклу 
  та за допомогою рекурсії (в окремих статичних методах).</p>
<h3>1.7 Квадратне рівняння</h3>
<p class="justified">Доробити програму обчислення квадратного кореня (Приклад 
  3.7) так, щоб здійснювалася перевірка можливості знайдення коренів. Функція 
  повинна повертати кількість коренів (-1 - безмежна кількість коренів). Забезпечити 
  введення коефіцієнтів рівняння з клавіатури.</p>
<h2>2 Методичні вказівки</h2>
<h3>2.1 Платформа .NET та мова програмування C#</h3>
<h4>2.1.1 Загальні концепції платформи .NET</h4>
<p class="justified"><i>Платформа .NET</i> <code>-</code> це програмне середовище, 
  яке забезпечує розробку та виконання програм, що спираються на загальномовну 
  інфраструктуру - спільне середовище часу виконання та спільний набір типів. 
  Як і в Java, є можливість створення програм, які можуть бути виконані у різних 
  операційних системах без перекомпіляції. Архітектура .NET спирається на набір 
  стандартів консорціуму WWW, перш за все йдеться про протокол HTTP (він є базовим 
  протоколом для технології Web-сервісів) і мови XML.</p>
<p class="justified">Реалізація .NET-платформи від Microsoft для MS Windows має 
  назву <i>.NET Framework</i> - набір базових засобів архітектури .NET, що забезпечують 
  розробку і виконання програм для платформи.NET. Засоби .NET Framework можуть 
  бути безкоштовно завантажені з сайту Microsoft. У порівнянні з попередніми технологіями, 
  які пропонувала Microsoft, платформа .NET має такі переваги:</p>
<ul>
  <li>керованість коду;</li>
  <li>єдина стандартизована бібліотека класів, заснована на ієрархії з єдиним 
    коренем;</li>
  <li>можливість розробляти компоненти, які описують себе самі (свої типи, класи, 
    інтерфейси) і не вимагають зовнішньої реєстрації для виконання.</li>
</ul>
<p class="justified">Існує декілька версій .NET Framework. Версія 3.5 автоматично 
  встановлюється під час інсталяції Windows 7. Лабораторні роботи цього курсу 
  орієнтовані на роботу з версією 4.0. Ця версія автоматично встановлюється під 
  час інсталяції MS Visual Studio 2010.</p>
<p class="justified">Засоби .NET Framework включають дві основні складові частини:</p>
<ul>
  <li>загальне середовище виконання (Common Language Runtіme, CLR);</li>
  <li>бібліотеку класів .NET Framework.</li>
</ul>
<p class="justified">Загальне середовище виконання (CLR) є основою .NET <code>-</code> 
  архітектури. Воно здійснює керування пам'яттю, роботу з потоками управління, 
  віддалене виконання коду, забезпечує безпеку і можливість розробки на різних 
  мовах програмування. </p>
<p class="justified">Компіляція програми з мови високого рівня виконується у два 
  етапи. Спочатку створюється модуль, який містить текст мовою <i>Common Intermediate 
  Language (CIL)</i>. Програмний код, керований CLR, називається <i>керованим 
  кодом</i> (managed code) на противагу некерованому (unmanaged code). На відміну 
  від Java, керований код не інтерпретується. Замість цього відбувається компіляція 
  коду, іменована<i> just-in-time</i> (JIT). Під час першого завантаження програми 
  цей код компілюється у машинні інструкції. Під час подальших запусків код одразу 
  виконується.</p>
<h4>2.1.2 Спільна система типів</h4>
<p class="justified">Для того, щоб у проектах могли здійснювати взаємодію частини, 
  які написані різними мовами програмування, ці частини повинні спиратися на<i> 
  Спільну систему типів</i> (Common Type System, CTS). Це можуть бути типи-значення 
  (value types) і типи-посилання (reference types). </p>
<p class="justified"><i>Типи-значення</i> містять свої дані безпосередньо і їхні 
  екземпляри розміщаються або в стеку, або як елементи структур. Такі типи можуть 
  бути вбудованими (реалізованими безпосередньо CLR), створеними користувачем 
  (структури), а також типами-переліченнями. </p>
<p class="justified"><i>Типи-посилання</i> містять посилання на адресу в пам'яті, 
  де зберігаються дані. Пам'ять під ці дані виділяється в керованій області (managed 
  heap). Такі типи далі підрозділяються на типи із самоописом (self-descrіbіng 
  types), до яких відносяться класові типи і масиви, типи-покажчики (pointer types) 
  і типи-інтерфейси (interface types).</p>
<p class="justified">Класові типи далі підрозділяються на звичайні користувальницькі 
  класи, оболонки для типів-значень (boxed value types) і делегати (delegates) 
  <code>-</code> деякий аналог покажчиків на функції.</p>
<p class="justified">Усі типи CLR входять в одну ієрархію зі спільним базовим 
  класом <code>System.Object</code>.</p>
<p class="justified">Бібліотека класів містить у собі набір класів та інтерфейсів, 
  які можна використовувати для розробки застосунків різної архітектури. Для розробки 
  Wіndows-застосунків використовується бібліотека Wіndows Forms. Бібліотека Web 
  Forms надає компоненти рівня серверу.</p>
<h4>2.1.3 Поняття складання</h4>
<p class="justified"><i>Складання</i> (assembly) <code>-</code> це набір типів 
  (разом з їхніми реалізаціями) і ресурсів, що розроблені для того, щоб працювати 
  разом, і формують логічну одиницю функціональності застосунку.</p>
<p class="justified">Складання містить код, який виконує CLR. Спеціальний блок 
  даних, який називається маніфестом складання, містить метадані, необхідні для 
  того, щоб інші складання могли знаходити типи і ресурси, які експортуються цим 
  складанням.</p>
<p class="justified">Складання є одиницею контролю версій. Вони також є одиницею 
  розгортання застосунку.</p>
<p class="justified">Складання можуть бути статичними і динамічними. Статичні 
  складання містяться у файлах (в одному чи кількох), наприклад, таке складання 
  може бути створене з одного файлу коду і декількох файлів ресурсів, динамічні 
  складання створюються у пам'яті і виконуються.</p>
<p class="justified">На кожному комп'ютері, на якому встановлено CLR, організується 
  т.зв. <i>глобальний кеш складань</i> (global assembly cache, GAC), в якому зберігаються 
  версії складань, призначених для використання різними застосунками.</p>
<h4>2.1.4 Основні характеристики мови програмування С#</h4>
<p class="justified">Незважаючи на те, що .NET допускає можливість використання 
  різних мов програмування, найбільш природно підтримка .NET реалізована в мові 
  C#, що може розглядатися як аналог Java.</p>
<p class="justified">С# увібрав у себе все краще з таких мов як C++, Visual Basic, 
  Java і Object Pascal. До особливостей мови можна віднести наступні:</p>
<ul>
  <li>об'єктна орієнтація;</li>
  <li>вбудована підтримка типів CTS;<br>
  </li>
  <li>строгий контроль типів;</li>
  <li>підтримка властивостей і подій;</li>
  <li>підтримка перевантаження операцій та індексаторів;</li>
  <li> автоматичне збирання сміття;<br>
  </li>
  <li>можливість маніпулювати вказівниками і мати безпосередній доступ до пам'яті 
    (у некерованому коді);<br>
  </li>
  <li>підтримка атрибутів;<br>
  </li>
  <li>множинне спадкування для інтерфейсів (як у Java).</li>
</ul>
<p class="justified">Протягом розробки мови C # було випущено шість її версій 
  - 1.0, 1.2, 2.0, 3.0, 4.0 та 5.0. Версія 4.0 з'явилася у квітні 2010 року, тому 
  для розробки програм з використанням можливостей цієї версії необхідно використовувати 
  середовище програмування MS Visual Studio 2010 або MS Visual C++ 2010 Express 
  Edition (останнє середовище є безкоштовним).</p>
<p class="justified">На відміну від С++, у С# немає глобальних змінних, функцій 
  чи процедур. Це зроблено з метою запобігання конфліктів імен. Програма складається 
  з одного чи більше описів типів - класів, інтерфейсів, структур, перелічень 
  або делегатів. Типи об'єднуються в так звані простори імен, які їх логічно групують. 
</p>
<p class="justified">Класи є найбільш розповсюдженими та універсальні типи з полями 
  (елементами даних) і методами (функціями-елементами), властивостями та іншими 
  елементами. Один із класів, які утворюють програму, повинен визначати статичний 
  метод <code>Main()</code>, з якого починається виконання цієї програми.</p>
<p class="justified">Програма може складатися з декількох файлів. За пошук потрібних 
  файлів під час виконання відповідають метадані, включені у складання (assemblies).</p>
<p class="justified">Компілятор C# не використовує препроцесування. Замість цього 
  набір <i>директив препроцесора</i> включено безпосередньо в мову. Директиви 
  препроцесора завжди починаються із символу #, після якого йде ім'я директиви. 
  Директива повинна знаходитися на окремому рядку вихідного файлу, після неї можуть 
  йти коментарі типу <code>//</code>. Директиви дозволяють</p>
<ul>
  <li>умовно пропускати фрагменти коду (<code>#define</code>, <code>#undef</code>, 
    <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, 
    використання аналогічне C++);</li>
  <li>генерувати повідомлення про помилки і попередження (<code>#warning</code> 
    і <code>#error</code> з відповідними рядками помилок);</li>
  <li>задавати іменовані фрагменти коду для ієрархічного відображення в Visual 
    Studio (<code>#region</code> код <code>#endregion</code>).</li>
</ul>
<p class="justified">Остання директива дозволяє задати іменований фрагмент коду, 
  який можна буде розкривати і ховати з використанням ієрархічного відображення 
  (outlines) у Visual Studio.</p>
<p class="justified">Директиви не дозволяють створювати макропідстановки і підключати 
  заголовні файли. Взагалі механізм заголовних файлів у C# не підтримується.</p>
<p class="justified"></p>
<h3>2.2 Створення консольного застосунку C# у середовищі програмування MS Visual 
  Studio 2010</h3>
<p class="justified">За умовчанням, після завантаження інтеґрованого середовища 
  MS Visual Studio 2010 всередині головного вікна відображається так звана стартова 
  сторінка (<tt>Start Page</tt>).</p>
<p class="justified">На стартовій сторінці інтеґрованого середовища розташовані 
  посилання на функції для установки налаштувань, доступу до інформації про новини, 
  пов'язані з MS Visual Studio, та доступ до інших ресурсів. На панелі <tt>Get 
  Started</tt> міститься список останніх рішень. <i>Рішення</i> (Solution) - це 
  концептуальний контейнер проекту або групи логічно зв'язаних проектів, які мають 
  спільні властивості та налаштування. <i>Проект</i> (Project) включає в себе 
  набір вихідних файлів, а також пов'язаних з ними метаданих, таких як посилання 
  та інструкції по збірці. Проект зазвичай продукує один або декілька бінарних 
  файлів як результат компіляції. Якщо рішення передбачає створення застосунку, 
  один (і тільки один) з проектів може бути позначений як стартовий.</p>
<p class="justified">Новий проект може бути створений декількома способами:</p>
<ul>
  <li>через стартову сторінку (Посилання <tt>New Project...</tt> );</li>
  <li>через головне меню (<tt>File | New | Project...</tt>);</li>
  <li>шляхом натиснення кнопки <tt>New Project</tt> стандартної панелі інструментів;</li>
  <li>клавішною комбінацією <tt>Ctrl+Shift+N</tt>.</li>
</ul>
<p class="justified">Далі на екрані з'являється вікно <tt>New Project</tt>, в 
  якому ми обираємо шаблон проекту. Нас цікавить елемент дерева шаблонів (<tt>Installed 
  Templates</tt>) <tt>Visual C#</tt>. У середній частині вікна обираємо <tt>Console 
  Application</tt>. Далі в нижній частині вікна слід обрати опцію <tt>Create directory 
  for solution</tt>. Далі можна змінити ім'я проекту (<tt>Name</tt>), теку, в 
  якій буде розташоване рішення (<tt>Location</tt>) та ім'я рішення (<tt>Solution 
  name</tt>). У нашому випадку ім'я проекту буде <tt></tt><tt>Hello</tt>, а ім'я 
  рішення <tt>- Labs</tt>. Після натиснення кнопки <tt>OK</tt>, Visual Studio 
  автоматично генерує вихідний файл <tt>Program.cs</tt> у підкаталогу <tt>Hello</tt> 
  теки <tt>Labs</tt>. Його текст буде таким:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> Hello
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
    }
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified"><i>Примітка</i>. Усі наведені вихідні тексти були створені 
  в інтеґрованому середовищі, в якому для відступів визначено 2 пропуски. Для 
  того, щоб установити такий розмір відступів, слід скористатися функцією меню 
  <tt>Tools | Options...</tt>, далі <tt>Text Editor | C# | Tabs</tt>, опцію <tt>Indenting</tt> 
  встановити у <tt>Smart</tt>, увести у полях <tt>Tab size</tt> та <tt>Indent 
  size</tt> значення 2 та обрати опцію <tt>Insert Spaces</tt>.</p>
<p class="justified">Текст програми містить підключення стандартних просторів 
  імен за допомогою директиви <b><code>using</code></b>, опис власного простору 
  імен (<b><code>namespace</code></b>) <code>-</code> <code>Hello</code> (збігається 
  з назвою проекту), опис всередині нового простору імен класу <code>Program</code> 
  зі статичною (<code><b>static</b></code>) функцією <code>Main()</code>. Всередині 
  тіла функції <code>Main()</code> (проміж фігурними дужками) додаємо рядок:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>void</b> Main(<b>string</b>[] args)
{
  Console.WriteLine(&quot;Привiт, свiт!&quot;);
}</pre>
  </blockquote>
</blockquote>
<p class="justified"><i>Примітка</i>. У стандартному консольному вікні некоректно 
  відображається українська літера <code>і</code>. Тому, замість української літери 
  <code>і</code> слід вживати відповідну англійську. </p>
<p class="justified">Програму можна завантажити на виконання, обравши функцію 
  головного меню <tt>Debug | Start Without Debugging</tt> або застосувавши клавішну 
  комбінацію <tt>Ctrl+F5</tt>. Як і очікувалося, у консольному вікні відображається 
  відповідний текст. </p>
<p class="justified">Програму можна спростити, видаливши підключення зайвих просторів 
  імен:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;

<b>namespace</b> Hello
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      Console.WriteLine(&quot;Привiт, свiт!&quot;);
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<p class="justified">Можна взагалі обійтися без директиви <code><b>using</b></code>, 
  а також без аргументів функції <code>Main()</code>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>namespace</b> Hello
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main()
    {
      System.Console.WriteLine(&quot;Привiт, свiт!&quot;);
    }
  }
}    </pre>
  </blockquote>
</blockquote>
<p class="justified">Іноді важливим є так званий код завершення, який програма 
  повертає операційній системі. Значення 0 (нуль) - це успішне завершення, інше 
  ціле число можна трактувати як помилку. Тоді функція <code>Main()</code> може 
  повернути ціле значення (<code><b>int</b></code>) замість <b><code>void</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>namespace</b> Hello
{
  <b>class</b> Program
  {
    <b>static</b> <b>int</b> Main()
    {
      System.Console.WriteLine(&quot;Привiт, свiт!&quot;);
      <b>return</b> 0;
    }
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Функція <code>Main()</code> та клас <code>Program</code> 
  можуть також мати атрибути <code><b>public</b></code> (відкритий).</p>
<p class="justified">Середовище MS Visual Studio надає зручні засоби зневадження 
  програми (debugging). Можна додати точку переривання (<tt>F9</tt>) у необхідному 
  рядку коду. Якщо тепер скористатися функцією меню <tt>Debug | Start Debugging 
  </tt>(<tt>F5</tt>), програма буде завантажена на виконання, але її виконання 
  буде призупинене у точці переривання. Зовнішній вигляд та розташування підвікон 
  середовища дещо зміняться. У закладках <tt>Autos</tt> та <tt>Locals</tt> можна 
  переглянути проміжні значення змінних. Зупинити виконання програми можна за 
  допомогою функції <tt>Stop Debugging</tt> (<tt>Shift+F5</tt>).</p>
<h3>2.3 Базовий синтаксис мови C#</h3>
<h4>2.3.1 Коментарі</h4>
<p class="justified">Усі мови програмування підтримують поняття коментаря. Коментарі 
  - це текст всередині вихідного коду, який не обробляє компілятор. Мова C# підтримує 
  три види коментарів: </p>
<ul>
  <li>у стилі C++ (<code>//</code> до кінця рядка)</li>
  <li>у стилі C (<code>/* */</code>)</li>
  <li>XML-коментарі, що використовуються для генерації документації (<code>///</code>). 
  </li>
</ul>
<p class="justified">За допомогою XML-коментарів можна згенерувати XML-документ, 
  з якого, в свою чергу, можна отримати стандартні файли документації (Help).</p>
<h4>2.3.2 Ідентифікатори, ключові та зарезервовані слова</h4>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified">Вихідний текст C#, який обробляє компілятор, складається 
  з лексем. <i>Лексема</i> (token) - це послідовність символів, що мають певне 
  сукупне значення. Проміж окремими лексемами розташовують розділювачі <code>-</code> 
  пропуск, табуляція, новий рядок тощо.</p>
<p>Лексеми поділяються на такі групи: </p>
<ul>
  <li>ключові (зарезервовані) слова</li>
  <li>ідентифікатори</li>
  <li>літерали (константи)</li>
  <li> знаки операцій. </li>
</ul>
<p>Як і C++, мова C# є чуттєвою до регістру (заголовні та малі літери відрізняються). 
  Для реперзентації символів використовується кодування Unicode. </p>
<p class="justified"><i>Ключові слова</i> (keywords) - це попередньо визначені 
  зарезервовані імена, які мають спеціальні значення для компілятора. Їх не можна 
  використовувати в програмі як ідентифікатори. Окрім зарезервованих ключових 
  слів, які є такими в будь-якому контексті, існують так звані <i>контекстно-залежні 
  ключові слова</i>. Такі слова не є зарезервованими і набувають статусу ключових 
  лише у певному контексті. Усього є 79 зарезервованих ключових слів. Приклади 
  таких слів - <b><code>int</code></b>, <b><code>double</code></b>, <b><code>if</code></b>, 
  <b><code>for</code></b>, <b><code>class</code></b>, <code> <b>struct</b></code> 
  тощо. Приклади контекстно-залежних ключових слів <code>-</code> <code><b>set</b></code>, 
  <code><b>get</b></code>, <code><b>var</b></code>, <code><b>value</b></code> 
  тощо. Версія 4.0 мови C# пропонує 23 контекстно-залежних ключових слова.</p>
<p class="justified"><i>Ідентифікатори</i> використовуються для іменування типів, 
  змінних, функцій та інших програмних об'єктів. Першим символом повинна бути 
  літера чи символ підкреслення (&quot;_&quot;, underscore character). Далі можуть 
  використовуватися також цифри. Використання символу підкреслення не є бажаним.</p>
<p class="justified">Доцільно використовувати змістовні імена, які відображають 
  природу об'єкта або функції. Не можна використовувати пропуски всередині ідентифікатора. 
  Тому, якщо необхідно створити ідентифікатор з кількох слів, ці слова пишуть 
  злито, починаючи друге, третє та інші слова з великої літери. Наприклад, можна 
  створити таке ім'я змінної:</p>
<blockquote> 
  <blockquote> 
    <pre class="justified">thisIsMyVariable</pre>
  </blockquote>
</blockquote>
<p class="justified">Для змістовних імен доцільно використовувати англійську мнемоніку. 
  Імена просторів імен, типів (класів, інтерфейсів, перелічень, структур, делегатів), 
  методів, відкритих полів і властивостей пишуться з великої літери, інші імена 
  <code>-</code> тільки з маленької.</p>
<p class="justified">Локальні змінні визначаються (створюються) всередині методів. 
  Опис локальних змінних у C# здійснюється аналогічно C++. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> i = 11;
<b>double</b> d= 0, x;
<b>float</b> f; <b>
int</b> j, k;</pre>
  </blockquote>
</blockquote>
<p class="justified">Локальні змінні можуть бути визначені в будь-якому місці 
  усередині тіла функції, а також у вкладеному блоці. У C# не можна у внутрішньому 
  блоці визначати імена, вже описані в зовнішньому блоці:</p>
<blockquote> 
  <blockquote> 
    <pre>{
  <b>int</b> i = 0;
  {
    <b>int</b> j = 1; // Змінна j визначається у внутрішньому блоці
    <b>int</b> i = 2; // Помилка! Змінна i визначена в зовнішньому блоці
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">На відміну від С++, у C# не можна оголошувати змінні без 
  їхнього створення. </p>
<p class="justified">Для ініціалізації змінних, а також у виразах всередині програмного 
  кода, використовують константи (літерали). Приклади таких літералів - <code>12</code>, 
  <code>0x22</code>, <code>3.1416</code>, <code>'k'</code> або <code>&quot;some 
  text&quot;</code>. Дуже часто доцільно створювати так звані іменовані константи. 
  Для цього використовують ключове слово <b><code>const</code></b>, яке стосовно 
  до імен змінних означає, що вони не можуть бути змінені, наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>const int</b> h = 0; 
<b>const double</b> pi = 3.14169265;
</pre>
  </blockquote>
</blockquote>
<h4>2.3.3 Типи даних</h4>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified"></p>
<p class="justified">Кожна змінна або константа має свій тип. Базові типи C# відповідають 
  прийнятій у .NET спільній системі типів. Для імен стандартних типів CTS у C# 
  створені зручні синоніми, що є ключовими словами мови. C# надає можливість користуватись 
  знаковими та беззнаковими цілими типами. Нижче наведено типи CTS і їхні синоніми, 
  які використовуються в C#. </p>
<div align="center"> 
  <table width="81%" border="1" cellspacing="0" cellpadding="3">
    <tr> 
      <td width="23%"> 
        <div align="center"><b>Тип CTS</b></div>
      </td>
      <td width="20%"> 
        <div align="center"><b>Тип C#</b></div>
      </td>
      <td width="57%"> 
        <div align="center"><b>Опис</b></div>
      </td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Object</code></td>
      <td width="20%"><b><code>object</code></b></td>
      <td width="57%">загальний базовий тип</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.String</code></td>
      <td width="20%"><b><code>string</code></b></td>
      <td width="57%">тип рядка</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.SByte</code></td>
      <td width="20%"><b><code>sbyte</code></b></td>
      <td width="57%">байт зі знаком</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Byte</code></td>
      <td width="20%"><b><code>byte</code></b></td>
      <td width="57%">байт без знаку</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Int16</code></td>
      <td width="20%"><b><code>short</code></b></td>
      <td width="57%">2-байтове число зі знаком</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.UInt16</code></td>
      <td width="20%"><b><code>ushort</code></b></td>
      <td width="57%">2-байтове число без знаку</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Int32</code></td>
      <td width="20%"><b><code>int</code></b></td>
      <td width="57%">4-байтове число зі знаком</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.UInt32</code></td>
      <td width="20%"><b><code>uint</code></b></td>
      <td width="57%">4-байтове число без знаку</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Int64</code></td>
      <td width="20%"><b><code>long</code></b></td>
      <td width="57%">8-байтове число зі знаком</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.UInt64</code></td>
      <td width="20%"><b><code>ulong</code></b></td>
      <td width="57%">8-байтове число без знаку</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Char</code></td>
      <td width="20%"><b><code>char</code></b></td>
      <td width="57%">2-байтовий Unicode-символ</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Single</code></td>
      <td width="20%"><b><code>float</code></b></td>
      <td width="57%">число з плаваючою точкою звичайної точності</td>
    </tr>
    <tr> 
      <td width="23%" height="26"><code>System.Double </code></td>
      <td width="20%" height="26"><b><code>double</code></b> </td>
      <td width="57%" height="26">число з плаваючою точкою подвійної точності</td>
    </tr>
    <tr> 
      <td width="23%"><code>System.Boolean</code></td>
      <td width="20%"><b><code>bool</code></b></td>
      <td width="57%">логічне значення (приймає значення <b><code>true</code></b> 
        і <b><code>false</code></b>)</td>
    </tr>
    <tr> 
      <td width="23%" height="23"><code>System.Decimal</code></td>
      <td width="20%" height="23"><b><code>decimal</code></b></td>
      <td width="57%" height="23">тип даних високої точності (16 байт)</td>
    </tr>
  </table>
</div>
<p align="center">&nbsp;</p>
<p class="justified">У наведеному списку <b><code>object</code></b> та <b><code>string</code></b> 
  є типами-посиланнями, всі інші - типами-значеннями.</p>
<p class="justified">Константи цілого типу записуються як послідовності десяткових 
  цифр. Тип константи за умовчанням - <code><b>int</b></code>. Він може бути уточнений 
  додаванням наприкінці константи суфіксів <code>L</code> і <code>l</code> (<b><code>long</code></b>), 
  <code>U</code> і <code>u</code> (<b><code>uint</code></b>). Цілі константи можуть 
  записуватися у вісімковій системі числення, у цьому випадку першою цифрою повинна 
  бути цифра 0, число може містити тільки цифри 0...7. Цілі константи можна записувати 
  й у шістнадцятковій системі числення, у цьому випадку запис константи починається 
  із символів 0x чи 0X. Для позначення цифр понад 9 використовуються латинські 
  літери a, b, c, d, e та f (великі або маленькі). Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> octal = 023; // 19
<b>int</b> hex = 0xEF;  // 239    </pre>
  </blockquote>
</blockquote>
<p class="justified"> Константи типу <b><code>char</code></b> беруть в одиночні 
  лапки (апострофи), значення константи задається або знаком з поточного набору 
  символів, або цілою константою, якій передує зворотна коса риска (символ із 
  заданим кодом). Є ряд спеціальних символів, що можуть використовуватись як значення 
  константи типу <b><code>char</code></b> (такі подвійні символи називаються керувальними 
  послідовностями, escape sequences): </p>
<blockquote> 
  <blockquote> 
    <pre>'\n' - новий рядок,
'\t' - горизонтальна табуляція,
'\r' - переведення на початок рядку, 
'\'' - одиночні лапки (апостроф),
'\"' - подвійні лапки,
'\\' - зворотна коса риска (backslash).</pre>
  </blockquote>
</blockquote>
<p class="justified">Для зберігання даних символьного типу в пам'яті використовується 
  таблиця Unicode.</p>
<p class="justified">Константи дійсних типів можуть записуватись у формі з крапкою 
  або в експонентному форматі і за умовчанням мають тип<b> <code>double</code></b>. 
  При необхідності тип константи можна уточнити, записавши наприкінці суфікс <code>f</code> 
  чи <code>F</code> для типу <b><code>float</code></b>, суфікс <code>d</code> 
  чи <code>D</code> для типу <b><code>double</code></b>. Константи типу <b><code>decimal</code></b> 
  використовують суфікс M (m). Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre>1.5f    // 1.5  типу float
2.4E-2d // 0.25 типу double
12.5m   // 12.5 типу decimal</pre>
  </blockquote>
</blockquote>
<p class="justified">Значення з плаваючою крапкою не можна присвоювати цілим змінним. 
  Перетворення до більш вузького типу (дійсного до цілого, числа з подвійною точністю 
  до числа з одинарною точністю) пов'язано з ризиком утрати даних і повинно здійснюватися 
  явно, а не за замовчуванням</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b>   i  = 10;
<b>float</b> f  = i;        // Таке перетворення допускається
<b>long</b>  l  = f;        // Помилка!
<b>long</b>  l1 = (<b>long</b>) f; // Явне пертворення типів</pre>
  </blockquote>
</blockquote>
<p class="justified"> Числа без десяткової крапки інтерпретуються як цілі (типу 
  <b><code>int</code></b>). Числа з плаваючою крапкою мають тип <b><code>double</code></b>. 
  Для приведення їх до більш вузьких типів використовується явне приведення типів: 
<blockquote> 
  <blockquote> 
    <pre><b>float</b> f  = 10.5;         // Помилка!
<b>float</b> f1 = (<b>float</b>) 10.5; // Явне приведення типів
<b>float</b> f2 = 10.5f;        // Уточнення типу константи. Помилки немає</pre>
  </blockquote>
</blockquote>
<p class="justified">Булевим (<b><code>bool</code></b>) змінним можна присвоювати 
  тільки константи<code><b> true</b></code> та <code><b>false</b></code>. Змінні 
  типу <b><code>boolean</code></b> не можна неявно чи явно приводити до інших 
  типів і навпаки.</p>
<p class="justified">Константа-рядок складається із символів, які беруть у подвійні 
  лапки. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre>&quot;Це рядок&quot;</pre>
  </blockquote>
</blockquote>
<p class="justified">Результат додавання рядку до змінної іншого типу забезпечує 
  перетворення значення в подання у вигляді рядка. Зокрема, такий підхід застосовують 
  для виведення значень декількох змінних. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> k = 1;
<b>double</b> d = 2.5;
Console.WriteLine(k + &quot; &quot; + d); // 1 2.5</pre>
  </blockquote>
</blockquote>
<p class="justified">Усі типи-посилання можуть отримувати значення <code><b>null</b></code> 
  (не посилається на жоден об'єкт). Крім того, існує спеціальний варіант типів-значень 
  - null-сумісні типи (nullable types). Для опису таких типів використовують конструкцію 
  <code>тип?</code>, де <code>тип</code> - один з можливих типів-значень, наприклад 
  <code><b>int</b>?</code>, <b> <code>double</code></b><code>?</code> тощо. Змінні 
  null-сумісних типів можуть отримувати значення, визначені для відповідного типу, 
  плюс значення <code><b>null</b></code>.</p>
<p class="justified">Використання типів <b><code>byte</code></b>, <b><code>sbyte</code></b>, 
  <b><code>short</code></b> и <b><code>ushort</code></b>, може призвести до неочевидних 
  помилок і виправдано тільки у виняткових випадках. </p>
<p class="justified">У C# у ряді випадків допускається неявне перетворення (приведення) 
  типів. Для арифметичних типів воно допускається, коли перетворення веде до розширення 
  типів. Константний вираз типу <b><code>int</code></b> може бути перетворений 
  у значення будь-якого цілого типу (навіть більш вузького), якщо його значення 
  потрапляє в діапазон для цього типу. Дані типу <b><code>char</code></b> можуть 
  бути неявно перетворені до цілих та плаваючих типів, але не навпаки. Немає неявного 
  перетворення <b><code>float</code></b> чи <b><code>double</code></b> у <b><code>decimal</code></b>. 
</p>
<p class="justified">Існує також явне перетворення типів:</p>
<blockquote> 
  <blockquote> 
    <pre>(тип) вираз</pre>
  </blockquote>
</blockquote>
<p class="justified">Таке перетворення використовується, якщо необхідне звуження 
  типів, для типів-посилань і т.д. Однак тип <b><code>bool</code></b> не може 
  бути перетворений ні в який інший тип, ані явно, ані неявно. Значення null-сумісних 
  типів неможна неявно перетворювати у відповідні типи-значення, оскільки можна 
  загубити значення 0. Тому необхідне явне перетворення.</p>
<p class="justified">Мова C# дозволяє підтримує створення вказівників. Використання 
  вказівників буде розглянуто в подальших темах.</p>
<p class="justified">На відміну від C++, компілятор не дозволяє використовувати 
  значення непроініціалізованих змінних. Це призводить до помилки компіляції: 
</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> m;
<b>int</b> n = m;    // Помилка!</pre>
  </blockquote>
</blockquote>
<p class="justified">Починаючи з версії мови 3.0, C# надає можливість створення 
  неявно типізованих локальних змінних. Для опису таких змінних застосовують контекстно-залежне 
  ключове слово <b><code>var</code></b>. Такі змінні обов'язково повинні бути 
  проініціалізовані. Тип змінної компілятор визначає відповідно до типу ініціалізуючого 
  виразу. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>var</b> i = 1;
<b>var</b> s = &quot;Hello&quot;;
</pre>
  </blockquote>
</blockquote>
<p>Незважаючи на те, що тип не вказано явно, компілятор створює змінну певного 
  типу. Після того, як змінна створена, неможна змінювати її тип:</p>
<p class="justified"></p>
<blockquote> 
  <blockquote> 
    <pre><b>var</b> k = 1;
<b>k</b> = &quot;Hello&quot;; // Помилка!
</pre>
  </blockquote>
</blockquote>
<h4>2.3.4 Вирази та операції </h4>
<p class="justified">Всередині методів класів, з яких складається програма, можуть 
  міститись твердження (оператори), які, у свою чергу, складаються з виразів. 
  <i>Вираз</i> складається з однієї чи кількох операцій. Об'єкти операцій мають 
  назву <i>операндів</i>. Операції бувають <i>унарними</i> (один операнд), <i>бінарними</i> 
  (два операнда) і <i>тернарними</i> (три операнда).</p>
<p class="justified">У C# підтримуються практично всі стандартні арифметичні й 
  логічні операції, а також операції порівняння мови С++. Ці операції мають такий 
  же пріоритет і асоціативність, як і в C++.</p>
<p class="justified">До <i>арифметичних операцій</i> належать +, - (бінарні й 
  унарні), *, / а також операція отримання залишку від ділення %. (тільки до цілих). 
  Якщо / застосовується до цілих, результатом ділення буде теж ціле, а залишок 
  відкидається. Якщо хоча б один операнд <code>-</code> типу з плаваючою крапкою 
  (дійсний), ми отримаємо дійсний результат.</p>
<blockquote> 
  <blockquote> 
    <pre class="justified">Console.WriteLine(1 / 2);   // 0
Console.WriteLine(1.0 / 2); // 0.5</pre>
  </blockquote>
</blockquote>
<p class="justified">До <i>операцій відношення</i> належать перевірка на рівність 
  <code>==</code> і на нерівність <code>!=</code>, а також перевірки <code>&gt; 
  </code>(більше) <code>&gt;=</code> (більше або дорівнює) <code>&lt; </code>(менше) 
  <code>&lt;=</code> (менше або дорівнює). До <i>логічних операцій</i> належать 
  логічне І <code>&amp;&amp;</code> і АБО <code>||</code>. Операції відношення 
  та логічні повертають значення типу <b><code>boolean</code></b>. Операції І 
  та АБО можна застосовувати побітові <code>&amp;</code> і <code>|</code>. У такому 
  випадку завжди здійснюється повне обчислення значень обох операндів, тоді як 
  обчислення значення другого операнду операцій <code>&amp;&amp;</code> і <code>||</code> 
  може не здійснюватись, якщо результат вже встановлено.</p>
<p class="justified">До <i>операцій присвоювання</i> відносяться операції простого 
  і складеного присвоювання. Результатом операції простого присвоювання є значення 
  того виразу, що присвоюється лівому операнду. Складене присвоювання можна подати 
  в загальному вигляді в такий спосіб:</p>
<blockquote> 
  <blockquote> 
    <pre>a op= b </pre>
  </blockquote>
</blockquote>
<p class="justified">У даному випадку op - арифметична чи побітова операція: <code>+ 
  - * / % | & ^ << >></code>. Кожна складена операція еквівалентна такому присвоюванню: 
</p>
<blockquote> 
  <blockquote> 
    <pre>a = (a) op (b);</pre>
  </blockquote>
</blockquote>
<p class="justified">Наприклад,</p>
<blockquote> 
  <blockquote> 
    <pre>x += 5;</pre>
  </blockquote>
</blockquote>
<p class="justified">що еквівалентно</p>
<blockquote> 
  <blockquote> 
    <pre>x = x + 5;</pre>
  </blockquote>
</blockquote>
<p class="justified"><i>Операція інкременту</i> ++ забезпечує збільшення цілої 
  змінної на одиницю. Вона має дві форми префіксну і постфіксну. Префіксна форма 
  забезпечує збільшення змінної до того, як значення операції буде використано, 
  а постфіксна <code>-</code> після. <i>Операція декременту</i> <code>-- </code>забезпечує 
  зменшення змінної на одиницю і правила її використання аналогічні.</p>
<p class="justified">На відміну від C++, <i>операція &quot;кома&quot;</i> може 
  бути застосована тільки в заголовках циклів, наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> i, j;
<b>for</b> (i = 0, j = 0; i &lt; 10; i++, j += 2) {
  Console.WriteLine(i + &quot; &quot; + j);    </pre>
  </blockquote>
</blockquote>
<p class="justified">Використання <i>побітових операцій</i> <code>&amp;</code> 
  (побітове І), <code>|</code> (побітове АБО), <code>^</code> (виключальне АБО), 
  <code>~</code> (побітове не), <code>&lt;&lt;</code> та <code>&gt;&gt;</code> 
  (побітовий зсув) аналогічне С++. </p>
<p class="justified"><i>Умовна операція</i> (тернарна) має такий вигляд: </p>
<blockquote> 
  <blockquote> 
    <pre>умова ? вираз1 : вираз2 </pre>
  </blockquote>
</blockquote>
<p class="justified">Спочатку обчислюється значення умови. Якщо воно істинне, 
  то обчислюється <code>вираз1</code> і його значення повертається умовною операцією. 
  Якщо значення умови хибне, то обчислюється <code>вираз2</code> і повертається 
  його значення. Далі у прикладі обчислюється мінімальне з двох чисел:</p>
<blockquote> 
  <blockquote> 
    <pre class="justified">min = a &lt; b ? a : b;</pre>
  </blockquote>
</blockquote>
<p class="justified">Дуже часто таку операцію необхідно використовувати для перевірки 
  змінних-посилань на нерівність <b><code>null</code></b>. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre>a = b != <b>null</b> ? b : c;    </pre>
  </blockquote>
</blockquote>
<p>де a, b та c - посилання. Для подібних перевірок (як для посилань, так і для 
  null-сумісних типів) у C# є спрощена операція:</p>
<blockquote> 
  <blockquote> 
    <pre>a = b ?? c;    </pre>
  </blockquote>
</blockquote>
<p>тобто <code>a</code> отримає значення <code>b</code>, якщо <code>b</code> - 
  не <code><b>null</b></code>, або <code>c</code> у протилежному випадку.</p>
<p class="justified">Порядок застосування унарних операцій та операцій присвоєння 
  &quot;справа наліво&quot;, а всіх інших операцій - &quot;зліва направо&quot;.</p>
<p class="justified">Нижче наводиться перелік операцій у порядку зниження пріоритету.</p>
<div align="center"> 
  <table width="75%" border="1" cellspacing="0" cellpadding="3">
    <tr> 
      <td width="64%"> 
        <div align="center"><b>Операція</b></div>
      </td>
      <td width="36%"> 
        <div align="center"><b>Позначення</b></div>
      </td>
    </tr>
    <tr> 
      <td width="64%">дужки <br>
        доступ до елементу<br>
        доступ по індексу<br>
        постфіксний інкремент і декремент <br>
        створення об'єкта <br>
        отримання інформації про тип<br>
        включення/відключення перевірки переповнення<br>
        значення за умовчанням<br>
        виклик безіменного метода<br>
        доступ до елемента структури через указівник</td>
      <td width="36%"><code>(x)</code><br>
        <code>x.y</code> <br>
        <code>a[i]</code> <br>
        <code>x++</code>, <code>x--</code> <br>
        <code><b>new<br>
        typeof</b></code><br>
        <code><b>checked</b>/<b>unchecked<br>
        default<br>
        delegate </b></code><br>
        <code>-&gt;</code> </td>
    </tr>
    <tr> 
      <td width="64%" height="103">унарні арифметичні операції<br>
        логічне заперечення<br>
        префіксний інкремент і декремент <br>
        приведення типу<br>
        узяття адреси<br>
        перевірка розміру </td>
      <td width="36%" height="103"><code>-,</code> <code>+</code><br>
        <code>!</code><br>
        <code>++x, </code><code>--x</code><br>
        <code>(T)x</code><code><b><br>
        </b>&amp;<b> <br>
        sizeof</b></code> </td>
    </tr>
    <tr> 
      <td width="64%">множення, ділення, одержання залишку</td>
      <td width="36%"><code>*,</code> <code>/,</code> <code>%</code></td>
    </tr>
    <tr> 
      <td width="64%">бінарне додавання і віднімання</td>
      <td width="36%"><code>+</code>, <code>-</code></td>
    </tr>
    <tr> 
      <td width="64%">зсув</td>
      <td width="36%"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
    </tr>
    <tr> 
      <td width="64%">операції відношення<br>
        операції перевірки та приведення поліморфних типів</td>
      <td width="36%"><code>&lt;,</code><code>&gt;,</code> <code>&lt;=,</code> 
        <code>&gt;=<br>
        <b>is</b>, <b>as</b></code></td>
    </tr>
    <tr> 
      <td width="64%">перевірка на рівність і нерівність (дорівнює не дорівнює)</td>
      <td width="36%"><code>==</code> <code>!=</code> </td>
    </tr>
    <tr> 
      <td width="64%">побітове чи логічне ТА</td>
      <td width="36%"><code>&amp;</code></td>
    </tr>
    <tr> 
      <td width="64%">побітове чи логічне XOR</td>
      <td width="36%"><code>^</code></td>
    </tr>
    <tr> 
      <td width="64%">побітове чи логічне АБО</td>
      <td width="36%"><code>|</code></td>
    </tr>
    <tr> 
      <td width="64%">логічне ТА</td>
      <td width="36%"><code>&amp;&amp;</code></td>
    </tr>
    <tr> 
      <td width="64%">логічне АБО</td>
      <td width="36%"><code>||</code></td>
    </tr>
    <tr> 
      <td width="64%">перевірка посилання на значення <code>null</code></td>
      <td width="36%"><code>??</code></td>
    </tr>
    <tr> 
      <td width="64%"> умовна операція (тернарна)</td>
      <td width="36%"><code>? :</code></td>
    </tr>
    <tr> 
      <td width="64%">присвоювання<br>
        лямбда-оператор<br>
      </td>
      <td width="36%"><code>=</code>, <code></code> <code>+=</code>, <code>-=</code>, 
        <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, 
        <code>|=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code><br>
        <code>=&gt; </code></td>
    </tr>
  </table>
</div>
<p align="center">&nbsp;</p>
<blockquote> 
  <blockquote> </blockquote>
</blockquote>
<h4></h4>
<p class="justified">Пріоритет додавання і віднімання нижче, ніж множення і ділення, 
  пріоритет присвоєння нижче, ніж арифметичних операцій і т.д. Для зміни послідовності 
  операцій слід використовувати дужки.</p>
<p class="justified"></p>
<p class="justified">Операція <code><b>sіzeof</b></code> повертає розмір в байтах 
  для так званих некерованих типів - вбудованих типів-значень, указівників, та 
  структур. Наприклад <code><b>sizeof</b>(short)</code> повертає 2, <b><code>sizeof</code></b><code>(<b>decimal</b>)</code> 
  повертає 16. Деякі операції призначені для роботи з указівниками та будуть розглянуті 
  пізніше. </p>
<p class="justified">Під час виконання математичних операцій можна включати і 
  виключати перевірку на переповнення. Для цього використовуються оператори <b><code>checked</code></b> 
  і <b><code>unchecked</code></b>. Після відповідного ключового слова використовується 
  вираз чи блок. У випадку <b><code>checked</code></b> виникає помилка компіляції 
  (якщо операнд <code>-</code> константа) чи генерується виняткова ситуація <code>System.OverflowExceptіon</code> 
  (якщо операнд <code>-</code> не константа) а у випадку <b><code>unchecked</code></b> 
  відбувається неявне звуження даних і ніякої помилки не генерується. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>byte</b> i = 255;<br><b>byte</b> k = <b>unchecked</b> ((<b>byte</b>) (i + 1)); // k == 0</pre>
  </blockquote>
</blockquote>
<p class="justified">або</p>
<ol>
  <blockquote> 
    <pre><b>byte</b> i = 255;<br><b>byte</b> k;
<b>checked
</b>{
  k = ((<b>byte</b>) (i + 1)); // Помилка під час виконання!
}</pre>
  </blockquote>
</ol>
<p class="justified">За умовчанням компілятор розглядає код як <b><code>unchecked</code></b>. 
</p>
<p class="justified">Побітові операції можуть застосовуватися не тільки до значень 
  цілого типу, але і до значень типу <b><code>bool</code></b>, у цьому випадку 
  вони працюють як логічні і теж повертають <b><code>bool</code></b>. Використання 
  побітових операцій <code>&amp;</code> та <code>|</code> замість логічних <code>&amp;&amp;</code> 
  та <code>||</code> забезпечує повне виконання виразів обох опреандів. Натомість, 
  застосування власне логічних операцій <code>&amp;&amp;</code> та <code>||</code> 
  передбачає обчислення значень виразів тільки до встановлення істини.<br>
</p>
<h4>2.3.5 Твердження (оператори). Керування виконанням програми</h4>
<p class="justified"><i>Твердження</i> (або інструкція, чи оператор. англ. statement) 
  <code>-</code> найменша автономна частина мови програмування. Програма являє 
  собою послідовність інструкцій. Більшість тверджень мови C# аналогічна твердженням 
  C++.</p>
<p class="justified"><i>Порожня інструкція</i> складається з однієї крапки з комою. 
</p>
<p class="justified"><i>Інструкція-вираз</i> є повний вираз, який закінчується 
  крапкою з комою. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre>k = i + j + 1;</pre>
  </blockquote>
</blockquote>
<p class="justified"><i>Складена інструкція</i> - це послідовність тверджень, 
  укладена у фігурні дужки. Складену інструкцію часто іменують блоком. Після фігурної 
  дужки, яка закриває блок, крапка з комою не ставиться. Синтаксично блок може 
  розглядатися як окрема інструкція, однак вона також має значення у визначенні 
  видимості і часу життя ідентифікаторів. Ідентифікатор, оголошений усередині 
  блоку, має область видимості від точки визначення до фігурної дужки, що закривається. 
  Блоки можуть необмежено вкладатися один в одного.</p>
<p class="justified"><i>Інструкції вибору</i> - умовна інструкція та перемикач. 
  Умовна інструкція застосовується в двох видах:</p>
<blockquote> 
  <blockquote> 
    <pre><b>if</b> (вираз-умова)
  інструкція1
<b>else</b>
  інструкція2
</pre>
  </blockquote>
</blockquote>
<p class="justified">або</p>
<blockquote> 
  <blockquote> 
    <pre><b>if</b> (умова)
  інструкція1</pre>
  </blockquote>
</blockquote>
<p class="justified"> Під час виконання цієї інструкції обчислюється вираз-умова 
  і, якщо це істина, то виконується інструкція1 а інакше - інструкція2. На відміну 
  від C++, вираз-умова може бути лише типу <code><b>bool</b></code>.</p>
<p class="justified"><i>Перемикач</i> дозволяє вибрати одну з кількох можливих 
  гілок обчислень і будується за схемою: </p>
<blockquote> 
  <blockquote> 
    <pre><b>switch</b> (вираз)
  блок</pre>
  </blockquote>
</blockquote>
<p class="justified">Блок має такий вигляд: </p>
<blockquote> 
  <blockquote> 
    <pre>{
  <b>case</b> константа_1: інструкції; <b>break</b>;
  <b>case</b> константа-2: інструкції; <b>break</b>;
  ...
  <b>default</b>: інструкції; <b>break</b>;
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Виконання перемикача полягає в обчисленні керуючого виразу 
  і переході до групи інструкцій, позначених <b><code>case</code></b>-міткою, 
  значення якої дорівнює керуючому виразу. Якщо такої мітки немає, виконуються 
  інструкції після мітки <b><code>default</code></b> (яка може бути відсутня). 
  Важливою відмінністю від С++ є обов'язковість використання <b><code>break</code></b> 
  чи <b><code>goto</code></b> у кожному варіанті. Наприклад,</p>
<blockquote> 
  <blockquote> 
    <pre><b>switch</b> (i) 
{
  <b>case</b> 1: Console.WriteLine(&quot;1&quot;);
          <b>break</b>;        // вихід з switch
  <b>case</b> 2: Console.WriteLine(&quot;2&quot;);
          <b>goto case</b> 3;  // перехід до іншого варіанту
  <b>case</b> 3: Console.WriteLine(&quot;2 or 3&quot;);
        // помилка компіляції - пропущений оператор переходу!
  <b>default</b>:Console.WriteLine(&quot;other values&quot;);
          <b>break</b>;
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Перехід не потрібен в тому випадку, якщо <b><code>case</code></b> 
  не містить тверджень. </p>
<p class="justified">Вирази в <b><code>switch</code></b> можуть бути не тільки 
  цілими, але й рядками. У цьому випадку константи варіантів (після <b><code>case</code></b>) 
  повинні теж бути рядками, наприклад</p>
<blockquote> 
  <blockquote> 
    <pre><b>case</b> &quot;some text&quot;:</pre>
  </blockquote>
</blockquote>
<p class="justified"><i>Інструкції циклу</i> представлені в трьох варіантах: цикл 
  із передумовою, цикл із постумою і цикл із параметром. </p>
<p class="justified">Цикл із передумовою будується за схемою</p>
<blockquote> 
  <blockquote> 
    <pre><b>while</b> (вираз-умова) 
  інструкція</pre>
  </blockquote>
</blockquote>
<p class="justified">На кожному повторенні циклу обчислюється вираз-умова і якщо 
  значення цього виразу дорівнює <b><code>true</code></b>, виконується інструкція 
  - тіло циклу. </p>
<p class="justified">Цикл із постумою будується за схемою</p>
<blockquote> 
  <blockquote> 
    <pre><b>do</b>
  інструкція
<b>while</b> (вираз-умова); </pre>
  </blockquote>
</blockquote>
<p class="justified">Вираз-умова обчислюється і перевіряється після кожного повторення 
  інструкції - тіла циклу, цикл повторюється, поки умова виконується. Тіло циклу 
  в циклі з постумою виконується принаймні один раз.</p>
<p class="justified">Цикл із параметром будується за схемою: </p>
<blockquote> 
  <blockquote> 
    <pre><b>for</b> (E1; E2; E3)
  інструкція</pre>
  </blockquote>
</blockquote>
<p class="justified">де E1, E2 і E3 <code>-</code> вирази скалярного типу. Цикл 
  з параметром реалізується за наступним алгоритмом: </p>
<ul>
  <li>обчислюється вираз E1 (зазвичай цей вираз виконує підготовку до початку 
    циклу); </li>
  <li>обчислюється вираз E2 і якщо він дорівнює <b><code>false</code></b>, виконується 
    перехід до наступної інструкції програми (вихід з циклу); </li>
  <li>якщо E2 дорівнює <b><code>true</code></b>, виконується інструкція - тіло 
    циклу; </li>
  <li>обчислюється вираз E3 - виконується підготовка до повторення циклу, після 
    чого знову виконується вираз E2. </li>
</ul>
<p class="justified">У наступному прикладі сума</p>
<blockquote> 
  <blockquote> 
    <pre>y = 1<font face="Courier New, Courier, mono"><sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + ... + n<sup>2</sup></font></pre>
  </blockquote>
</blockquote>
<p class="justified"></p>
<p class="justified">знаходиться за допомогою трьох різних циклічних інструкцій.</p>
<p class="justified">За допомогою циклу <b><code>while</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> y = 0;
<b>int</b> i = 1;
<b>while</b> (i &lt;= n) {
  y += i * i;
  i++;
}</pre>
  </blockquote>
</blockquote>
<p class="justified"></p>
<p class="justified">За допомогою циклу <b><code>do ... while</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> y = 0;
<b>int</b> i = 1;
<b>do</b> {
  y += i * i;
  i++;
}
<b>while</b> (i &lt;= n);</pre>
  </blockquote>
</blockquote>
<p class="justified"></p>
<p class="justified">За допомогою циклу <b><code>for</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> y = 0;
<b>for</b> (<b>int</b> i = 1; i &lt;= n; i++)
  y += i * i;
</pre>
  </blockquote>
</blockquote>
<p class="justified">Циклчні конструкції можна вкладати одну в іншу.</p>
<p class="justified">У сполученні з інструкціями циклу використовуються <i>інструкції 
  переходу</i> <code>-</code> оператор <b><code>break</code></b>, який дозволяє 
  перервати виконання найвнутрішнішого з циклів, оператор <b><code>continue</code></b>, 
  який перериває поточну ітерацію найвнутрішнішого з циклів <b><code>while</code></b>, 
  <b><code>do</code></b> або <b><code>for</code></b>. Найчастіше <b><code>break</code></b> 
  використовують у такій конструкції:</p>
<blockquote> 
  <blockquote> 
    <pre><b>if</b> (умова_дострокового_завершення_циклу)
  <b>break</b>;</pre>
  </blockquote>
</blockquote>
<p class="justified">У C# є твердження <b><code>goto</code></b> для переходу на 
  мітку. Єдиний випадок, коли використання <b><code>goto</code></b> виправдане, 
  - це переривання декількох вкладених циклів. Наприклад: </p>
<blockquote> 
  <blockquote> 
    <pre><b>  int</b> a;
  . . .
<b>  double</b> b = 0;<b>  
  for</b> (<b>int</b> i = 0; i &lt; 10; i++) {
    <b>for</b> (<b>int</b> j = 0; j &lt; 10; j++) {
      <b>if</b> (i + j + a == 0) {
        <b>goto</b> label;
      }
      b += 1 / (i + j + a);
    }
  }
label:
  // інші інструкції</pre>
  </blockquote>
</blockquote>
<p class="justified">Існує додаткова циклічна конструкція <b><code>foreach</code></b> 
  для обходу масивів і колекцій.</p>
<h3>2.4 Простори імен</h3>
<p class="justified">Синтаксис і використання <i>просторів імен</i> у C# в основному 
  аналогічні C++. Наприклад, так описується простір імен:</p>
<blockquote> 
  <blockquote> 
    <pre><b>namespace</b> NewSpace
{
  <b>public class</b> SomeClass
  {
    <b>public void</b> f()
    {
    }
  }
    
  <b>namespace</b> InnerSpace
  {
    
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Як видно з наведеного прикладу, простір імен групує класи 
  (та інші типи), а також може включати інші простори імен. Як і в C++, простір 
  імен може бути продовжений в будь-якому місці програми, у тому числі в інших 
  файлах. Простори можна вкладати один в інший. Замість створення декількох вкладених 
  просторів можна описувати простори імен з крапками. Наприклад, замість наступного 
  опису </p>
<blockquote> 
  <blockquote> 
    <pre><b>namespace</b> First
{
  <b>namespace</b> Second
  {
    <b>namespace</b> Third
    {
    }
  }
}    </pre>
  </blockquote>
</blockquote>
<p class="justified">можна застосувати більш компактний:</p>
<blockquote> 
  <blockquote> 
    <pre><b>namespace</b> First.Second.Third
{

}    </pre>
  </blockquote>
</blockquote>
<p class="justified">Якщо простір імен у файлі не задано, то мається на увазі, 
  що усі імена з цього файлу містяться усередині спеціального простору імен за 
  умовчанням <code>-</code> глобального простору імен. Такий простір генерується 
  автоматично.</p>
<p class="justified"></p>
<p class="justified">На відміну від C++, доступ до елементів простору імен ззовні 
  здійснюється через крапку, а не через <code>::</code>. Для підключення всіх 
  описів простору імен можна використовувати директиву <b><code>using</code></b>:<br>
</p>
<ol>
  <blockquote> 
    <pre><b>using</b> NewSpace;

<b>namespace</b> OtherSpace { 
  <b>public class</b> Test {
    <b>public void</b> g() {
      SomeClass sc = <b>new</b> SomeClass();  // ім'я типу без префіксу імені простору
      sc.f();
    }
  }
}</pre>
  </blockquote>
</ol>
<p class="justified">За допомогою <b><code>using</code></b> у C# можна створювати 
  синоніми для просторів імен. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> S = System;
...
  S.Console.WriteLine();
</pre>
  </blockquote>
</blockquote>
<p class="justified">Як видно з наведеного прикладу, до елементів простору імен 
  можна звертатися через крапку. Але для більш адекватним є використання операції 
  <code>::</code>. В такому випадку одразу видно, що йдеться про синонім:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> S = System;
...
  S::Console.WriteLine();</pre>
  </blockquote>
</blockquote>
<p class="justified">У C# визначене контекстно-залежне ключове слово <b><code>global</code></b> 
  - синонім глобального простору імен. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>  global</b>::System.Console.WriteLine();    </pre>
  </blockquote>
</blockquote>
<p class="justified">Цей синонім застосовують для запобігання конфліктам імен.</p>
<h3>2.5 Функції</h3>
<p class="justified">У C# немає глобальних функцій. Аналогом глобальної функції 
  є статичний метод класу. Опис статичної функції у найпростішому випадку має 
  таку структуру:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> тип_результату ім'я_функції(список_формальних_параметрів) тіло</pre>
  </blockquote>
</blockquote>
<p class="justified">Параметри (аргументи) функції, що вказуються в списку у визначенні 
  функції, називаються <i>формальними</i>. Параметри, що вказуються під час виклику 
  функції, називаються <i>фактичними</i>. Під час виклику функції виділяється 
  пам'ять під її формальні параметри, потім кожному формальному параметру присвоюється 
  значення фактичного параметра. </p>
<p class="justified">Тіло функції являє собою складений оператор (блок). Наприклад, 
  визначення статичної функції, що обчислює суму двох цілих чисел, може бути таким:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>int</b> Sum(<b>int</b> a, <b>int</b> b)
{
  <b>int</b> c = a + b;
  <b>return</b> c;
} </pre>
  </blockquote>
</blockquote>
<p class="justified">Можна взагалі обійтися без змінної с:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>int</b> Sum(<b>int</b> a, <b>int</b> b)
{
  <b>return</b> a + b;
} </pre>
  </blockquote>
</blockquote>
<p class="justified">Виклик функції може бути здійснений у виразі в описі або 
  в тілі іншої функції. Під час виклику функції вказується її ім'я і список фактичних 
  параметрів без зазначення їхніх типів:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> x = 4;
<b>int</b> y = 5;
<b>int</b> z = Sum(a, b);
<b>int</b> t = Sum(1, 3); </pre>
  </blockquote>
</blockquote>
<p class="justified">Функція може бути без параметрів:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>int</b> Zero()
{
  <b>return</b> 0;
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Викликаючи таку функцію, також необхідно використовувати 
  дужки:</p>
<blockquote> 
  <blockquote> 
    <pre>Console.WriteLine(Zero());</pre>
  </blockquote>
</blockquote>
<p class="justified">Інструкція <b><code>return</code></b> у тілі функції забезпечує 
  завершення роботи функції. Значення виразу після <b><code>return</code></b> 
  стає значенням функції, яке ця функція повертає.</p>
<p class="justified">Функція може не повертати ніякого результату. Для позначення 
  цього використовується тип <b><code>void</code></b>..</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>void</b> Hello()
{
  Console.WriteLine(&quot;Hello!&quot;);
}</pre>
  </blockquote>
</blockquote>
<p class="justified">У цьому випадку в тілі функції <b><code>return</code></b> 
  може бути відсутнім. Якщо інструкція <b><code>return</code></b> присутня, то 
  після неї не повинно бути ні якого виразу. Таку функцію можна викликати тільки 
  окремою інструкцією.</p>
<blockquote> 
  <blockquote> 
    <pre>Hello();</pre>
  </blockquote>
</blockquote>
<p class="justified">Функцію можна викликати з тіла цієї ж функції. <i>Рекурсія</i> 
  - це виклик функції з неї самої безпосередньо або опосередковано.</p>
<p class="justified">За умовчанням параметри передаються до функцій за значенням, 
  тобто значення фактичних параметрів копіюються в пам'ять, відведену для формальних 
  параметрів. При цьому значення, з якими працює функція - це її власні локальні 
  копії фактичних параметрів і їхня зміна на ці параметри не впливає. Таким чином, 
  при передачі за значенням вміст фактичних параметрів не змінюється:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;

<b>namespace</b> SwapperApp
{
  <b>class</b> Program
  {
    <b>static void</b> F(<b>int</b> k)
    {
      k++;       // k = 2;
    }

<b>    static void </b>Main(<b>string</b>[] args)
    {
  <b>    int</b> k = 1;
      F(k);
      Console.WriteLine(k); // k = 1;
    }
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Мова C# також підтримує передачу параметрів типів-значень 
  за посиланням. Існує два способи опису таких параметрів. Перший спосіб припускає, 
  що до виклику методу передані змінні були проініціалізовані. Для передачі параметрів 
  за посиланням використовується ключове слово <b><code>ref</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static void</b> Swap(<b>ref int</b> a, <b>ref int</b> b) 
{
  <b>int</b> c = a;
  a = b;
  b = c;
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Під час виклику такого методу і передачі йому фактичних параметрів 
  також варто використовувати ключове слово <b><code>ref</code></b>. Фактичні 
  параметри повинні бути обов'язково проініціалізовані. Наведемо повний приклад 
  використання функції<code> swap()</code>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;

<b>namespace</b> SwapperApp
{
  <b>class</b> Program
  {
    <b>static void</b> Swap(<b>ref int</b> a, <b>ref int</b> b) 
    {
      <b>int</b> c = a;
      a = b;
      b = c;
    }
 
    <b>static void</b> Main(<b>string</b>[] args)
    {
      <b>int</b> x = 1;
      <b>int</b> y = 10;
      <b></b>Swap(<b>ref</b> x, <b>ref</b> y); 
      <b></b>Console.WriteLine("x = " + x + " y = " + y); 
    }
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Як видно з приклада, цілі (та інші вбудовані) типи можна 
  зшивати з рядками за допомогою операції додавання. При цьому дані автоматично 
  перетворюються в строкове подання. </p>
<p class="justified">Другий спосіб використовується в тих випадках, коли функція 
  повинна повернути більш ніж одне значення. Для специфікації передачі параметрів 
  за посиланням використовується ключове слово <b><code>out</code></b>. Компілятор 
  стежить за тим, щоб у тілі функції таким параметрам були присвоєні значення. 
  Під час виклику функції для фактичних параметрів також необхідно вказувати слово 
  <b><code>out</code></b>.</p>
<p class="justified">У C# можна перевантажувати імена функцій. Перевантаженням 
  імені називається його використання для позначення різних операцій над різними 
  типами. </p>
<p class="justified"> Якщо списки формальних параметрів збігаються, але типи значень, 
  що повертаються, різні, компілятор повідомляє про помилку. Якщо списки формальних 
  параметрів двох функцій розрізняються числом чи параметрів їхніми типами, то 
  ці дві функції вважаються перевантаженням однієї функції і повинні мати різні 
  визначення.</p>
<p class="justified">Перевантажені функції використовуються в тих випадках, якщо 
  кілька функцій виконує схожі дії над об'єктами різних типів і зручно дати однакові 
  імена всім цим функціям:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static int</b> Мax(<b>int</b> a, <b>int</b> b) { }                 // Вибір максимального з двох цілих чисел
<b>static int</b> Мax(<b>double</b> x, <b>double</b> y, <b>double</b> z) { } // Вибір максимального з трьох дійсних чисел
</pre>
  </blockquote>
</blockquote>
<p class="justified">Для того, щоб визначити, яку саме функцію варто викликати, 
  порівнюються кількість і типи фактичних параметрів, зазначені у виклику, з кількістю 
  і типами формальних параметрів всіх описів функцій з даним ім'ям. У результаті 
  викликається та функція, у якої формальні параметри щонайкраще зіставилися з 
  параметрами виклику, чи видається помилка, якщо такої функції не знайшлося.</p>
<p class="justified">Версія 4.0 мови C# (рік) дозволяє описувати функції з параметрами 
  за умовчанням (як і в C++). Такий підхід дозволяє викликати одну функцію з різною 
  кількістю параметрів. Наприклад: </p>
<blockquote> 
  <blockquote> 
    <pre><b>static double</b> Sum(<b>double</b> a, <b>double</b> b = 0, <b>double</b> c = 0)
{
  <b>return</b> a + b + c;
}</pre>
  </blockquote>
</blockquote>
<p>Цю функцію можна викликати або з одним, або з двома, або з трьома параметрами:</p>
<blockquote> 
  <blockquote> 
    <pre><b>double</b> x = 0.1;
<b>double</b> y = 0.2;
<b>double</b> z = 0.3;
Console.WriteLine(Sum(x));
Console.WriteLine(Sum(x, y));
Console.WriteLine(Sum(x, y, z));</pre>
  </blockquote>
</blockquote>
<p> З наведеного приклада видно, що якщо значення параметрів за умовчанням задовольняють 
  наші потреби, під час виклику відповідні фактичні параметри можна не вказувати. 
  Параметри за умовчанням задаються в списку останніми, інакше ми отримаємо повідомлення 
  про синтаксичну помилку:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static void</b> F(<b>double</b> x, <b>int</b> y = 0, <b>int</b> h) { } // Синтаксична помилка!</pre>
  </blockquote>
</blockquote>
<p class="justified">Під час виклику можна вказувати імена формальних параметрів 
  (у версії 4.0 мови C#). Вказується ім'я параметру та після двокрапки - його 
  значення. Наприклад, у наступному фрагменті програми обчислюється вираз <i>y</i> 
  = <i>ax</i> + <i>b</i>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>double</b> Y(<b>double</b> a, <b>double</b> x, <b>double</b> b)
{
  <b>return</b> a * x + b;
}

<b>static</b> <b>void</b> Main(<b>string</b>[] args)
{
  Console.WriteLine(Y(a: 2, x: 3, b: 4)); // 10
}    </pre>
  </blockquote>
</blockquote>
<p class="justified">Ця можливість є особливо корисною в поєднанні з параметрами 
  за умовчанням. Вона дозволяє вказувати лише необхідні параметри. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>static</b> <b>double</b> Y(<b>double</b> a = 1, <b>double</b> x = 0, <b>double</b> b = 0)
{
  <b>return</b> a * x + b;
}

<b>static</b> <b>void</b> Main(<b>string</b>[] args)
{
  Console.WriteLine(Y(a: 2, x: 3, b: 4)); // 10
  Console.WriteLine(Y(x: 5, b:11));       // 16
  Console.WriteLine(Y(x: 5));             // 5
  Console.WriteLine(Y());                 // 0
}    </pre>
  </blockquote>
</blockquote>
<p class="justified">Параметри з іменами повинні бути останніми у списку фактичних 
  параметрів. </p>
<p class="justified">Статичні функції в межах класу викликаються з застосуванням 
  лише імені функції та списку фактичних параметрів. Для того, щоб викликати статичну 
  функцію іншого класу, необхідно вказувати його ім'я і далі через точку ім'я 
  функції. В такий спосіб можна звертатись до імен у межах поточного простору 
  імен. </p>
<h3>2.6 Використання математичних функцій</h3>
<p class="justified">Простір імен System, окрім консольного введення та виведення, 
  містить велику кількість корисних класів, зокрема клас <code>Math</code>, який 
  надає велику кількість математичних функцій.</p>
<p class="justified">Таблиця 2.2 - Найбільш вживані математичні функції класу 
  <code>Math</code></p>
<table width="100%" border="1" cellspacing="0" cellpadding="6">
  <tr> 
    <td width="28%"> 
      <div align="center"><b>Функція</b></div>
    </td>
    <td width="50%"> 
      <div align="center"><b>Зміст</b></div>
    </td>
    <td width="22%"> 
      <div align="center"><b>Приклад виклику</b></div>
    </td>
  </tr>
  <tr> 
    <td width="28%" height="15"> 
      <div align="left"><code><b>double</b> Pow(<b>double</b> a, <b>double</b> 
        b)</code></div>
    </td>
    <td width="50%" height="15"> 
      <div align="left">Обчислення <i>a<sup>b</sup></i></div>
    </td>
    <td width="22%" height="15"> 
      <div align="left"><code>Math</code>.<code>Pow(x, y)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"> 
      <div align="left"><code><b>double</b> Sqrt(<b>double</b> a)</code></div>
    </td>
    <td width="50%"> 
      <div align="left">Обчислення квадратного кореня</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Sqrt(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"> 
      <div align="left"><code><b>double</b> Sin(<b>double</b> a)</code></div>
    </td>
    <td width="50%"> 
      <div align="left">Обчислення синуса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Sin(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"> 
      <div align="left"><code><b>double</b> Cos(<b>double</b> a)</code></div>
    </td>
    <td width="50%"> 
      <div align="left">Обчислення косинуса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Cos(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"><code><b>double</b> Tan(<b>double</b> a)</code></td>
    <td width="50%"> 
      <div align="left">Обчислення тангенса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Tan(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"><code><b>double</b> Asin(<b>double</b> a)</code></td>
    <td width="50%"> 
      <div align="left">Обчислення арксинуса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Asin(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"><code><b>double</b> Acos(<b>double</b> a)</code></td>
    <td width="50%"> 
      <div align="left">Обчислення арккосинуса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Acos(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"><code><b>double</b> Atan(<b>double</b> a)</code></td>
    <td width="50%"> 
      <div align="left">Обчислення арктангенса</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Atan(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"> 
      <div align="left"><code><b>double</b> Exp(<b>double</b> a)</code></div>
    </td>
    <td width="50%"> 
      <div align="left">Обчислення <i>e<sup>x</sup></i></div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Exp(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%"> 
      <div align="left"><code><b>double</b> Log(<b>double</b> a)</code></div>
    </td>
    <td width="50%"> 
      <div align="left">Обчислення натурального логарифма</div>
    </td>
    <td width="22%"> 
      <div align="left"><code>Math</code>.<code>Log(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%" height="23"> 
      <div align="left"><b><code>double</code></b><code> Abs(<b>double</b> a)</code></div>
      <code><b>int</b> Abs(<b>int</b> a)</code></td>
    <td width="50%" height="23"> 
      <div align="left">Знаходження модуля числа</div>
    </td>
    <td width="22%" height="23"> 
      <div align="left"><code>Math</code>.<code>Abs(x)</code></div>
    </td>
  </tr>
  <tr> 
    <td width="28%" height="12"> 
      <div align="left"><code><b>double</b><code></code> Round(<b>double</b> a)</code></div>
    </td>
    <td width="50%" height="12"> 
      <div align="left">Округлення до найближчого цілого</div>
    </td>
    <td width="22%" height="12"> 
      <div align="left"><code>Math</code>.<code>Round(x)</code></div>
    </td>
  </tr>
</table>
<p class="justified">Окрім математичних функцій, клас <code>Math</code> надає 
  такі корисні константи, як <code>Math.PI</code>, <code>Math.E</code>.</p>
<h3>2.7 Консольне виведення та введення</h3>
<p class="justified"></p>
<p class="justified">Для консольного виведення та введення застосовують клас <code>Console</code> 
  простору імен <code>System</code>. Функція <code>Write()</code> виводить указані 
  дані починаючи з поточного місця консольного вікна. У найпростішому випадку 
  - це параметр будь-якого типу. Функція <code>WriteLine()</code> крім того здійснює 
  перехід на новий рядок. Виклик <code>WriteLine()</code> без параметрів забезпечує 
  перехід на новий рядок.</p>
<p class="justified">Першим параметром <code>Write()</code> та <code>WriteLine()</code> 
  можна вказати рядок формату виведення. У фігурних дужках вказуються індекси 
  параметрів, що вказані далі. Фактично значення, які виводяться, включаються 
  у рядок у вказаних місцях. Ці значення перелічують через кому. Наприклад, після 
  виконання наступного фрагмента коду, </p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> k = 10;
<b>double</b> b = 2;
Console.WriteLine(&quot;k = {0}, b = {1}&quot;, k, b);    </pre>
  </blockquote>
</blockquote>
<p class="justified">ми отримаємо такі дані у консольному вікні:</p>
<blockquote> 
  <blockquote> 
    <pre>k = 10, b = 2</pre>
  </blockquote>
</blockquote>
<p class="justified">Завдяки такому підходу можна здійснити форматоване виведення 
  даних. Для цього після індексу параметра слід вказати параметр форматування 
  - велику або маленьку літеру, яка показує тип форматування:</p>
<blockquote> 
  <blockquote> 
    <p><code>d - </code>десяткове (ціле) число<br>
      <code>f - </code>дійсне число з фіксованою крапкою<br>
      <code>e - </code>експоненційна форма числа<br>
      <code>x - </code>шістнадцяткове число</p>
  </blockquote>
</blockquote>
<p class="justified">Є також інші символи форматування. Після символів можна додавати 
  цілі значення - ширину поля виведення. Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> i = 10;
Console.WriteLine(&quot;{0:d8}&quot;, i);      // 00000010
Console.WriteLine(&quot;{0:x}&quot;, i);       // a
<b>double</b> d = 2012;
Console.WriteLine(&quot;{0:f6}&quot;, d);      // 2012.000000
Console.WriteLine(&quot;{0:f} {0:e}&quot;, d); // 2012.00 2.012000e+003    </pre>
  </blockquote>
</blockquote>
<p class="justified">Останній приклад показує, що одне значення можна вивести 
  декілька разів завдяки рядку форматування.</p>
<p class="justified">Для введення даних застосовують функцію <code>ReadLine()</code> 
  класу <code>Console</code>. Ця функція повертає рядок, який можна перетворити 
  на необхідне число за допомогою статичних функцій <code>Parse</code>, які реалізовані 
  для стандартних типів-значень (<b><code>int</code></b>, <b><code>double</code></b> 
  тощо). Наприклад:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> i = <b>int</b>.Parse(Console.ReadLine());
<b>double</b> d = <b>double</b>.Parse(Console.ReadLine());    </pre>
  </blockquote>
</blockquote>
<h2>3 Приклади програм</h2>
<h3>3.1 Середнє арифметичне</h3>
<p class="justified">Необхідно ввести з клавіатури два числа (дійсне та ціле) 
  і обчислити їх середнє арифметичне.</p>
<p class="justified"">У середовищі MS Visual Studio створюємо новий проект<code></code> 
  - консольний застосунок C# з ім'ям <code>Average</code>. Одержуємо наступний 
  код:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> Average
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
    }
  }
}
    </pre>
  </blockquote>
</blockquote>
<p class="justified">Тепер всередині функції <code>Maіn()</code> описуємо дві 
  змінні, наприклад, <code>a</code> і <code>b</code>, читаємо їхні значення з 
  клавіатури і обчислюємо значення <code>c</code>, що є їхнім середнім арифметичним.</p>
<blockquote> 
  <blockquote> 
    <pre><b>double</b> a = <b>double</b>.Parse(Console.ReadLine());
<b>int</b> b = <b>int</b>.Parse(Console.ReadLine());
<b>double</b> c = (a + b) / 2;    </pre>
  </blockquote>
</blockquote>
<p class="justified">Визначення (опис) змінної, як і в C++, можна поєднувати з 
  присвоєнням початкового значення (ініціалізацією). У даному випадку створюється 
  змінна <code>b</code> типу <code>int</code>, а також змінні <code>a</code> і 
  <code>c</code> типу <b><code>double</code></b>. Після ініціалізації змінної 
  c необхідний результат вже обчислений. Його необхідно вивести на екран (у консольне 
  вікно):</p>
<blockquote> 
  <blockquote> 
    <pre>Console.WriteLine("Середнє арифметичне: " + c);</pre>
  </blockquote>
</blockquote>
<p class="justified">У даному рядку плюс означає не додавання, а зшивання рядків. 
  До строкової константи <code>"Середнє арифметичне: "</code> пришивається рядкове 
  представлення значення змінної<code> c</code>.</p>
<p>Тепер можна навести повний текст програми.</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> Average
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>double</b> a = <b>double</b>.Parse(Console.ReadLine());
      <b>int</b> b = <b>int</b>.Parse(Console.ReadLine());
      <b>double</b> c = (a + b) / 2;
      Console.WriteLine(&quot;Середнє арифметичне: &quot; + c);
    }
  }
}
    </pre>
  </blockquote>
</blockquote>
<p class="justified">Після запуску програми слід увести в різних рядках значення 
  <code>a</code> та <code>b</code>, після чого в консольному вікні з'явиться результат. 
<h3>3.2 Робота з перемикачем</h3>
<p>Припустимо, необхідно створити програму, в якій з клавіатури вводяться цілі 
  значення <i>x</i> та обчислюються значення <i>y</i> відповідно до наступної 
  таблиці:</p>
<div align="center"> 
  <table width="40%" border="1" cellspacing="0" cellpadding="3">
    <tr> 
      <td> 
        <div align="center"><i><b>x</b></i></div>
      </td>
      <td> 
        <div align="center"><i><b>y</b></i></div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">1</div>
      </td>
      <td> 
        <div align="center">12</div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">2</div>
      </td>
      <td> 
        <div align="center">14</div>
      </td>
    </tr>
    <tr> 
      <td> 
        <div align="center">інше значення</div>
      </td>
      <td> 
        <div align="center">16</div>
      </td>
    </tr>
  </table>
</div>
<div align="center"></div>
<p>&nbsp;</p>
<p>Програма може бути наступною (після видалення зайвих <b><code>using</code></b>-тверджень):</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;

<b>namespace</b> Switcher
{
  <b>class</b> Program
  {
    
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>int</b> x = <b>int</b>.Parse(Console.ReadLine());
      <b>int</b> y;
      <b>switch</b> (x)
      {
        <b>case</b> 1:  y = 12; <b>break</b>;
        <b>case</b> 2:  y = 14; <b>break</b>;
        <b>default</b>: y = 16; <b>break</b>;
      }
      Console.WriteLine(y);
    }
  }
}</pre>
  </blockquote>
</blockquote>
<h3>3.3 Степені числа 2</h3>
<p class="justified">Необхідно ввести n та вивести на екран степені числа 2 - 
  від першого до n-го.</p>
<p class="justified"> Створюємо новий консольний застосунок - <code>Powers</code>. 
  Для виконання однотипних дій доцільно створити цикл, у тілі якого обчислюється 
  черговий степінь 2 та виводиться на екран. На C# цей алгоритм можна представити 
  в наступному вигляді:</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> n = <b>int</b>.Parse(Console.ReadLine());
<b>int</b> k = 2;  // основа степеня
<b>int</b> power = 1;
<b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) 
{
  power *= k;
  Console.WriteLine(&quot;{0} -й степiнь: {1}&quot;, i, power);
}</pre>
  </blockquote>
</blockquote>
<p class="justified">У цьому прикладі для опису змінних використовується тип<b><code> 
  int</code></b> (цілий), тому що і основа степеня, і показник, і степінь <code>-</code> 
  цілі числа. Початкове значення результату</p>
<blockquote> 
  <blockquote> 
    <pre><b>int</b> power = 1;</pre>
  </blockquote>
</blockquote>
<p class="justified">є типовим для обчислення добутків послідовностей Як видно 
  з прикладу, параметр циклу можна визначати безпосередньо в заголовку циклу. 
  Для множення, як і в інших мовах програмування, використовується знак зірочки. 
  Замість традиційного для багатьох мов твердження</p>
<blockquote> 
  <blockquote> 
    <pre>power = power * k;    </pre>
  </blockquote>
</blockquote>
<p class="justified">можна записати</p>
<blockquote> 
  <blockquote> 
    <pre>power *= k;    </pre>
  </blockquote>
</blockquote>
<p class="justified">Програма матиме такий вигляд:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> Powers
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>int</b> n = <b>int</b>.Parse(Console.ReadLine());
      <b>int</b> k = 2;  // основа степеня
      <b>int</b> power = 1;
      <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) 
      {
        power *= k;
        Console.WriteLine(&quot;{0} -й степiнь: {1}&quot;, i, power);
      }
    }
  }
}</pre>
  </blockquote>
</blockquote>
<p class="justified">Припустимо, що ми ввели значення 20. Отримаємо наступні результати 
  у консольному вікні:</p>
<blockquote> 
  <blockquote> 
    <pre>1-й степінь: 2
2-й степінь: 4
3-й степінь: 8
4-й степінь: 16
5-й степінь: 32
6-й степінь: 64
7-й степінь: 128
8-й степінь: 256
9-й степінь: 512
10-й степінь: 1024
11-й степінь: 2048
12-й степінь: 4096
13-й степінь: 8192
14-й степінь: 16384
15-й степінь: 32768
16-й степінь: 65536
17-й степінь: 131072
18-й степінь: 262144
19-й степінь: 524288
20-й степінь: 1048576    </pre>
  </blockquote>
</blockquote>
<h3>3.4 Сума цифр</h3>
<p class="justified">Припустимо, необхідно обчислити суму цифр числа. Можна використовувати 
  знаходження залишку від ділення.</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> SumOfDigits
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>int</b> n = <b>int</b>.Parse(Console.ReadLine());
      <b>int</b> sum = 0;
      <b>while</b> (n &gt; 0) {
        sum += n % 10;
        n /= 10;
      }
      Console.WriteLine(sum);
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<h3>3.5 Застосування null-сумісних типів</h3>
<p>Припустимо, необхідно розробити функцію обчислення зворотної величини. Ця функція 
  не може бути обчислена, якщо аргумент дорівнює 0. У якості типу результату функції 
  можна застосувати null-сумісний тип. У функції <code>Main()</code> здійснюємо 
  тестування.</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> ReciprocalTest
{
  <b>class</b> Program
  {
    <b>static</b> <b>double</b>? Reciprocal(<b>double</b> x)
    {
      <b>if</b> (x == 0)
        <b>return</b> <b>null</b>;
      <b>return</b> 1 / x;
    }

    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      Console.Write(&quot;Уведiть x: &quot;);
      <b>double</b> x = <b>double</b>.Parse(Console.ReadLine());
      <b>double</b>? y = Reciprocal(x);
      <b>if</b> (y == <b>null</b>)
        Console.WriteLine(&quot;Помилка&quot;);
      <b>else</b>
        Console.WriteLine(y);
    }
  }
}</pre>
  </blockquote>
</blockquote>
<h3>3.6 Найбільший спільний дільник</h3>
<p class="justified">Припустимо, необхідно обчислити найбільший спільний дільник. 
  Скористаємось алгоритмом Евкліда, який полягає у послідовному відніманні меншого 
  числа з більшого та заміні більшого числа отриманою різницею. Алгоритм завершується, 
  коли два числа збігатимуться. Програма матиме такий вигляд:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> GreatestCommonDivisor
{
  <b>class</b> Program
  {
    <b>static</b> <b>int</b> GCD(<b>int</b> m, <b>int</b> n)
    {
      <b>while</b> (m != n)
      {
        <b>if</b> (m &gt; n)
          m -= n;
        <b>else</b>
          n -= m;
      }
      <b>return</b> m;
    }

    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>int</b> m = <b>int</b>.Parse(Console.ReadLine());
      <b>int</b> n = <b>int</b>.Parse(Console.ReadLine());
      Console.WriteLine(GCD(m, n));
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<p class="justified">Результат роботи можна використати для обчислення найменшого 
  спільного кратного чисел. Для цього їхній добуток слід поділити на найбільший 
  спільний дільник.</p>
<h3>3.7 Розв'язання квадратного рівняння</h3>
<p class="justified"> У наступному прикладі розв'язується квадратне рівняння. 
  Приклад демонструє застосування параметрів з модифікатором <b><code>out</code></b>:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;

<b>namespace</b> QuadraticApp
{
	
  <b>class</b> Quadratic
  {
    <b>public static void</b> Solve(<b>double</b> a, <b>double</b> b, <b>double</b> c,
                             <b>out double</b> x1, <b>out double</b> x2)
	{
      <b>double</b> d = b * b - 4 * a * c;
      x1 = (-b - Math.Sqrt(d)) / (2 * a);
      x2 = (-b + Math.Sqrt(d)) / (2 * a);
    }

    <b>static void</b> Main(<b>string</b>[] args)
    {
      <b>double</b> x1, x2;
      Solve(1, 1, -2, <b>out</b> x1, <b>out</b> x2);
      Console.WriteLine(&quot;x1 = {0} x2 = {1}&quot;, x1, x2);
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<p class="justified">Як видно з наведеного приклада, для виклику математичних 
  функцій застосовують клас <code>Math</code>.</p>
<p class="justified"><i>Примітка</i>: Наведена програма не є цілком коректною, 
  оскільки не здійснюється перевірка додатності дискримінанту, а також значення 
  коефіцієнту <i>a</i> (він не може дорівнювати 0).</p>
<h3>3.8 Рекурсія</h3>
<p class="justified">Припустимо, необхідно створити рекурсивну функцію обчислення 
  цілого степеня дійсного числа та здійснити тестування для різних значень. Програма 
  матиме такий вигляд:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> IntPower
{
  <b>class</b> Program
  {
    <b>static</b> <b>double</b>? Power(<b>double</b> x, <b>int</b> n)
    {
      <b>if</b> (x == 0 &amp;&amp; n == 0)
        <b>return</b> <b>null</b>;
      <b>if</b> (n &lt; 0)
        <b>return</b> 1 / Power(x, -n);
      <b>if</b> (n == 0)
        <b>return</b> 1;
      <b>return</b> x * Power(x, n - 1);
    }

    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      Console.Write(&quot;Уведiть x: &quot;);
      <b>double</b> x = <b>double</b>.Parse(Console.ReadLine());
      Console.Write(&quot;Уведiть n: &quot;);
      <b>int</b> n = <b>int</b>.Parse(Console.ReadLine());
      <b>double</b> p = Power(x, n) ?? <b>double</b>.NaN;
      Console.WriteLine(&quot;Степiнь: &quot; + p);
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<h3>3.9 Обчислення виразу</h3>
<p class="justified">Необхідно прочитати з клавіатури <i>x</i> та обчислити <i>y</i> 
  за такою формулою:</p>
<p align="center"><img src="Images/01_Formula.gif" width="201" height="140"></p>
<p class="justified">де <span class="formula">n</span> дорівнює 6. Обчислення 
  виразу слід розмістити в окремій функції. Програма може мати такий вигляд:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> Formula
{
  <b>class</b> Program
  {
    <b>static</b> <b>double</b> f(<b>double</b> x) {
      <b>const</b> <b>int</b> n = 6;
      <b>double</b> y;
      <b>if</b> (x &lt; 0) {
        y = 0;
        <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++)
          y += (i - x) * (i - x);
      }
      <b>else</b> {
        y = 1;
        <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++)
          y *= (x + i);
      }
      <b>return</b> y;
    }

    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>double</b> x = <b>double</b>.Parse(Console.ReadLine());
      <b>double</b> y = f(x); // Виклик функції
      Console.WriteLine(&quot;x = {0} y = {1}&quot;, x, y);
    }
  }
}
</pre>
  </blockquote>
</blockquote>
<h3>3.10 Таблиця значень квадратних коренів чисел</h3>
<p class="justified">Необхідно прочитати з клавіатури значення початку інтервалу, 
  кінця інтервалу, величини кроку, з яким змінюється аргумент та у циклі вивести 
  значення квадратних коренів чисел. Програма може мати такий вигляд:</p>
<blockquote> 
  <blockquote> 
    <pre><b>using</b> System;
<b>using</b> System.Collections.Generic;
<b>using</b> System.Linq;
<b>using</b> System.Text;

<b>namespace</b> SquareRoots
{
  <b>class</b> Program
  {
    <b>static</b> <b>void</b> Main(<b>string</b>[] args)
    {
      <b>double</b> from = <b>double</b>.Parse(Console.ReadLine());
      <b>double</b> to = <b>double</b>.Parse(Console.ReadLine());
      <b>double</b> step = <b>double</b>.Parse(Console.ReadLine());
      <b>if</b> (from &lt; 0 || to &lt; 0 || from &gt;= to || step &lt;= 0)
        Console.WriteLine(&quot;Невірні дані&quot;);
      <b>else</b> {
        // Основний цикл програми:
        <b>for</b> (<b>double</b> x = from; x &lt;= to; x += step)
          Console.WriteLine(&quot;x = {0}\t y = {1}&quot;, x, Math.Sqrt(x));
      }
    }
  }
}
    </pre>
  </blockquote>
</blockquote>
<p class="justified">У результаті виконання цієї програми на консолі з'являться 
  пари значень <i>x</i> та <i>y</i>.</p>
<blockquote> 
  <blockquote></blockquote>
</blockquote>
<h2>4 Вправи для контролю</h2>
<p>Усі вправи передбачають створення консольного застосунку. Обчислення основного 
  результату здійснити в окремій статичній функції, яка викликається з функції 
  <code>main()</code>. Введення та виведення здійснювати у функції <code>main()</code>. 
</p>
<ol>
  <li>Увести два дійсних числа. Знайти та вивести середнє арифметичне квадратів 
    чисел. </li>
  <li>Увести два дійсних числа. Знайти та вивести середнє геометричне – квадратний 
    корінь з їхнього добутку. Якщо корінь не можна обчислити, вивести повідомлення 
    про помилку.</li>
  <li>Увести ціле додатне число. Знайти та вивести добуток цифр цього числа.</li>
  <li>Увести ціле додатне число. Знайти та вивести суму парних цифр цього числа.</li>
  <li>Увести ціле додатне число. Знайти та вивести суму квадратів цифр цього числа.</li>
  <li>Увести ціле додатне число. Знайти та вивести суму непарних цифр цього числа.</li>
  <li>Увести ціле додатне число. Знайти та вивести добуток парних цифр цього числа.</li>
  <li>Увести ціле додатне число. Знайти та вивести добуток непарних цифр цього 
    числа.</li>
  <li>Увести ціле додатне число. Перевірити, чи є воно простим. Вивести відповідно 
    &quot;yes&quot; або &quot;no&quot;. Число називається простим, якщо у нього 
    рівно два дільника - 1 і дане число.<br>
  </li>
  <li>Увести ціле додатне число. Перевірити, чи є воно точним квадратом іншого 
    цілого числа. Вивести знайдене число, або &quot;no&quot; в іншому випадку.</li>
  <li>Увести два цілих додатних числа. Знайти та вивести найменше спільне кратне 
    цих чисел.</li>
  <li>Увести дійсне число та цілий показник степеня (додатний або від'ємний). 
    Обчислити степінь за допомогою циклу та вивести на екран.</li>
  <li>Увести ціле додатне число n. Знайти та вивести добуток перших n додатних 
    непарних цілих чисел.</li>
  <li>Увести цілі додатні числа n та m, m &lt; n. Знайти та вивести добуток перших 
    n додатних цілих чисел, виключаючи m.</li>
  <li>Увести цілі додатні числа n та m, m &lt; n. Знайти та вивести суму перших 
    n додатних цілих чисел, виключаючи m.</li>
  <li>Увести ціле число – кількість градусів кута. Знайти та вивести величину 
    синуса кута.</li>
  <li>Увести ціле число – кількість градусів кута. Знайти та вивести величину 
    косинуса кута.</li>
  <li>Увести ціле число – кількість градусів n. Знайти та вивести суму синусів 
    кутів з градусами від одиниці до n.</li>
  <li>Створити рекурсивну функцію обчислення суми квадратів перших n чисел.</li>
  <li>Створити рекурсивну функцію обчислення добутку синусів перших n натуральних 
    чисел.</li>
</ol>
<h2>5 Контрольні запитання</h2>
<ol>
  <li>У чому полягає призначення платформи .NET?</li>
  <li>Які відмінності використання директив препроцесора C# у порівнянні з C++?</li>
  <li>Як пов'язані типи C# зі стандартними типами CLR?</li>
  <li>У чому полягають переваги та недоліки синтаксису мови C# (у порівнянні з 
    С++)?</li>
  <li>Яка різниця між зарезервованими і контекстно-залежними ключовими словами?</li>
  <li>Чим відрізняються XML-коментарі від інших видів коментарів?</li>
  <li>Чим відрізняються примітивні типи даних C# від аналогічних типів C++?</li>
  <li>Для чого використовують керуючі послідовності?</li>
  <li>Як здійснюється приведення типів?</li>
  <li>У чому полягають особливості типу <b>bool</b>?</li>
  <li>Як привести значення вираз типу <b>bool</b> до цілого типу?</li>
  <li>Чим відрізняється префіксна та постфіксна форма операцій інкременту та декременту?</li>
  <li> Чи можна застосовувати операцію &amp; замість &amp;&amp; для операндів 
    типу <b>bool</b>?</li>
  <li>Для чого використовують <b>null</b>-сумісні типи?</li>
  <li>Де може бути використана операція &quot;кома&quot;?</li>
  <li>Яке призначення тернарної опреації?</li>
  <li>Як може бути використана операція <b>sizeof</b>?</li>
  <li>У чому переваги використання <b>checked</b>/<b>unchecked</b> блоків?</li>
  <li>У чому полягають особливості використання <b>switch</b> у C#?</li>
  <li>Чим відрізняється цикл з передумовою від циклу з постумовою?</li>
  <li>Чим відрізняється цикл з передумовою від циклу з параметром?</li>
  <li>Як здійснюється опис та підключення просторів імен?</li>
  <li>Чим відрізняються формальні та фактичні параметри функцій?</li>
  <li>Чи можна використовувати інструкцію <b>return</b> у тілі функції з типом 
    результату <b>void</b>?</li>
  <li>Чим відрізняється передача параметрів за значенням і за посиланням?</li>
  <li>У чому полягає різниця між модифікаторами <b>out</b> та <b>ref</b>?</li>
  <li>У чому полягає перевантаження імен функцій?</li>
  <li>Чим перевантаження імен функцій відрізняється від визначення функції з параметрами 
    за умовчанням?</li>
  <li>Які недоліки й переваги явного визначення імен формальних параметрів під 
    час виклику функції?</li>
  <li>Як викликати функцію з іншого класу?</li>
  <li>Як викликати функцію з іншого простору імен?</li>
  <li>Як здійснюється форматування даних під час виведення?</li>
</ol>
<p class="justified">&nbsp;</p>
<p class="justified"><a href="Index.htm">Зміст</a>&nbsp;&nbsp;&nbsp;&nbsp;Попередня 
  лабораторна робота&nbsp;&nbsp;&nbsp;&nbsp;<a href="LabTraining02.htm">Наступна 
  лабораторна робота</a></p>
<p class="justified">&nbsp;</p>
<p class="justified">© 2004-2013 Л.В.Іванов</p>
</body>
</html>
